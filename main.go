package main

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"strings"

	"github.com/IBM/sarama"
	_ "github.com/lib/pq"
)

type CVERecord struct {
	Containers struct {
		CNA struct {
			Affected []struct {
				Product  string `json:"product"`
				Vendor   string `json:"vendor"`
				Versions []struct {
					Status  string `json:"status"`
					Version string `json:"version"`
				} `json:"versions"`
			} `json:"affected"`
			Descriptions []struct {
				Lang  string `json:"lang"`
				Value string `json:"value"`
			} `json:"descriptions"`
			ProblemTypes []struct {
				Descriptions []struct {
					Description string `json:"description"`
					Lang        string `json:"lang"`
					Type        string `json:"type"`
				} `json:"descriptions"`
			} `json:"problemTypes"`
			ProviderMetadata struct {
				DateUpdated string `json:"dateUpdated"`
				OrgID       string `json:"orgId"`
				ShortName   string `json:"shortName"`
			} `json:"providerMetadata"`
			References []struct {
				Name string   `json:"name"`
				Tags []string `json:"tags"`
				URL  string   `json:"url"`
			} `json:"references"`
			XLegacyV4Record struct {
				CVEDataMeta struct {
					Assigner string `json:"ASSIGNER"`
					ID       string `json:"ID"`
					State    string `json:"STATE"`
				} `json:"CVE_data_meta"`
				Affects struct {
					Vendor struct {
						VendorData []struct {
							Product struct {
								ProductData []struct {
									ProductName string `json:"product_name"`
									Version     struct {
										VersionData []struct {
											VersionValue string `json:"version_value"`
										} `json:"version_data"`
									} `json:"version"`
								} `json:"product_data"`
							} `json:"product"`
							VendorName string `json:"vendor_name"`
						} `json:"vendor_data"`
					} `json:"vendor"`
				} `json:"affects"`
				DataFormat  string `json:"data_format"`
				DataType    string `json:"data_type"`
				DataVersion string `json:"data_version"`
				Description struct {
					DescriptionData []struct {
						Lang  string `json:"lang"`
						Value string `json:"value"`
					} `json:"description_data"`
				} `json:"description"`
				ProblemType struct {
					ProblemTypeData []struct {
						Description []struct {
							Lang  string `json:"lang"`
							Value string `json:"value"`
						} `json:"description"`
					} `json:"problemtype_data"`
				} `json:"problemtype"`
				References struct {
					ReferenceData []struct {
						Name      string `json:"name"`
						Refsource string `json:"refsource"`
						URL       string `json:"url"`
					} `json:"reference_data"`
				} `json:"references"`
			} `json:"x_legacyV4Record"`
		} `json:"cna"`
	} `json:"containers"`
	CveMetadata struct {
		AssignerOrgID     string `json:"assignerOrgId"`
		AssignerShortName string `json:"assignerShortName"`
		CveID             string `json:"cveId"`
		DatePublished     string `json:"datePublished"`
		DateReserved      string `json:"dateReserved"`
		DateUpdated       string `json:"dateUpdated"`
		State             string `json:"state"`
		Version           string `json:"version"`
	} `json:"cveMetadata"`
	DataType    string `json:"dataType"`
	DataVersion string `json:"dataVersion"`
}

func main() {
	// Database configuration
	dbInfo := fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=%s sslmode=disable",
		os.Getenv("DB_HOST"), os.Getenv("DB_PORT"), os.Getenv("DB_USER"), os.Getenv("DB_PASSWORD"),
		os.Getenv("DB_NAME")) 

	db, err := sql.Open("postgres", dbInfo)
	if err != nil {
		log.Fatalf("Error opening database: %v", err)
	}
	defer db.Close()

	err = db.Ping()
	if err != nil {
		log.Fatalf("Error pinging database: %v", err)
	}
	log.Println("Successfully connected to the database")

	// Ensure the database schema exists
	_, err = db.Exec(`CREATE SCHEMA IF NOT EXISTS cve`)
	if err != nil {
		log.Fatalf("Error creating schema: %v", err)
	}

	// Create the cve table if it doesn't exist
	_, err = db.Exec(`
        CREATE TABLE IF NOT EXISTS cve.cve (
            id TEXT,
            version INTEGER,
            assigner_org_id TEXT,
            assigner_short_name TEXT,
            date_published TEXT,
            date_reserved TEXT,
            date_updated TEXT,
            state TEXT,
            data JSONB,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            PRIMARY KEY (id, version)
        )
    `)
	if err != nil {
		log.Fatalf("Error creating cve table: %v", err)
	}

	// Create indexes
	_, err = db.Exec(`
        CREATE INDEX IF NOT EXISTS idx_cve_data_gin ON cve.cve USING GIN (data);
        CREATE INDEX IF NOT EXISTS idx_cve_metadata_gin ON cve.cve USING GIN ((data->'cveMetadata'));
    `)
	if err != nil {
		log.Fatalf("Error creating indexes: %v", err)
	}

	// Kafka configuration
	brokerString := os.Getenv("KAFKA_BROKERS")
	if brokerString == "" {
		log.Fatal("KAFKA_BROKERS environment variable is not set")
	}
	brokers := strings.Split(brokerString, ",")

	topic := os.Getenv("KAFKA_TOPIC")
	if topic == "" {
		log.Fatal("KAFKA_TOPIC environment variable is not set")
	}

	config := sarama.NewConfig()
	config.Consumer.Return.Errors = true
	config.Version = sarama.V2_8_0_0 // Use the version that matches your Kafka server

	consumer, err := sarama.NewConsumer(brokers, config)
	if err != nil {
		log.Fatalf("Error creating Kafka consumer: %v", err)
	}
	defer consumer.Close()

	partitionConsumer, err := consumer.ConsumePartition(topic, 0, sarama.OffsetNewest)
	if err != nil {
		log.Fatalf("Error creating partition consumer: %v", err)
	}
	defer partitionConsumer.Close()

	signals := make(chan os.Signal, 1)
	done := make(chan struct{})

	log.Println("Consumer started. Waiting for messages...")

	go func() {
		for {
			select {
			case msg := <-partitionConsumer.Messages():
				log.Printf("Received message from partition %d at offset %d", msg.Partition, msg.Offset)
				processAndStoreCVE(db, msg.Value)
			case err := <-partitionConsumer.Errors():
				log.Printf("Error: %v", err)
			case <-signals:
				done <- struct{}{}
				return
			}
		}
	}()

	<-done
	log.Println("Consumer stopped")
}

func processAndStoreCVE(db *sql.DB, data []byte) {
	log.Printf("Processing message with length %d bytes", len(data))

	var cveRecord CVERecord
	err := json.Unmarshal(data, &cveRecord)
	if err != nil {
		log.Printf("Error parsing CVE JSON data: %v", err)
		return
	}

	log.Printf("Parsed CVE record: %s", cveRecord.CveMetadata.CveID)

	// Check if the CVE record already exists
	var existingVersion sql.NullInt64
	var count int

	err = db.QueryRow("SELECT MAX(version) FROM cve.cve WHERE id = $1", cveRecord.CveMetadata.CveID).Scan(&existingVersion)
	if err != nil && err != sql.ErrNoRows {
		log.Printf("Error checking existing CVE record: %v", err)
		return
	}

	err = db.QueryRow("SELECT COUNT(*) FROM cve.cve WHERE id = $1", cveRecord.CveMetadata.CveID).Scan(&count)
	if err != nil && err != sql.ErrNoRows {
		log.Printf("Error checking existing CVE record: %v", err)
		return
	}

	if count > 0 {
		log.Printf("Skipping already processed CVE: %s (version %s)", cveRecord.CveMetadata.CveID, cveRecord.CveMetadata.Version)
		return
	}

	var newVersion int
	if existingVersion.Valid {
		newVersion = int(existingVersion.Int64) + 1
		log.Printf("Existing version found for %s: %d. New version will be %d", cveRecord.CveMetadata.CveID, existingVersion.Int64, newVersion)
	} else {
		newVersion = 1
		log.Printf("No existing version found for %s. Inserting as version 1", cveRecord.CveMetadata.CveID)
	}

	// Insert or update the CVE record
	result, err := db.Exec(`
        INSERT INTO cve.cve (id, version, assigner_org_id, assigner_short_name, date_published, date_reserved, date_updated, state, data)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
        ON CONFLICT (id, version) DO UPDATE SET
            assigner_org_id = EXCLUDED.assigner_org_id,
            assigner_short_name = EXCLUDED.assigner_short_name,
            date_published = EXCLUDED.date_published,
            date_reserved = EXCLUDED.date_reserved,
            date_updated = EXCLUDED.date_updated,
            state = EXCLUDED.state,
            data = EXCLUDED.data
    `, cveRecord.CveMetadata.CveID, newVersion, cveRecord.CveMetadata.AssignerOrgID, cveRecord.CveMetadata.AssignerShortName,
		cveRecord.CveMetadata.DatePublished, cveRecord.CveMetadata.DateReserved, cveRecord.CveMetadata.DateUpdated,
		cveRecord.CveMetadata.State, data)

	if err != nil {
		log.Printf("Error inserting/updating CVE record: %v", err)
	} else {
		rowsAffected, _ := result.RowsAffected()
		log.Printf("Successfully processed CVE: %s (version %d). Rows affected: %d", cveRecord.CveMetadata.CveID, newVersion, rowsAffected)
	}
}
